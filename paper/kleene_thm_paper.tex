\documentclass{bcthesis}

%%% Other packages needed by your document may be loaded here.
\usepackage{url}              % For formatting URLs 
\usepackage{booktabs}         % Publication-quality tables.
\usepackage[square, numbers]{natbib}           % Provides some nice citation and
							  % bibliography formatting commands.
% \bibpunct[:~]{(}{)}{;}{a}{,}{,~} % Set some defaults for bibliographic
								 % punctuation used by natbib.sty.
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{calc}
\usepackage{subfig}
\usepackage{textcomp}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage{standalone}
% \usepackage{showframe}
\usepackage{james}
\usepackage[plainpages=false,pdfpagelabels, hidelinks]{hyperref}

\usetikzlibrary{arrows, automata}

%%% Document Settings
	% The following command allows tables to split between pages:
	\allowdisplaybreaks

	% Provide additional context around errors. 
	\setcounter{errorcontextlines}{1000}

	\setlength{\parskip}{0.5 em}

	\newif\ifbuildfrontmatter
	\buildfrontmatterfalse
	% \buildfrontmattertrue

	% Use this to toggle professionalism
	\newif\ifpresstime
	\presstimefalse
	% \presstimetrue

	\ifpresstime
		\buildfrontmattertrue
		\renewcommand{\meo}{}
		\allhrfalse
	\fi

	\tikzset{
		initial text = {\scriptsize{\textsc{start}}},
		initial distance = 1 pt,
		every initial by arrow/.style={->}
	}


%%% End document settings

%%% Begin information section 
	%% title of your report?
	\title{An Exemplified Proof of Kleene's Theorem}

	%% Your name 
	\author{James McFeeters}

	% Photo -- see bcthesis class line 168

	\advisor{Darrah Chavey}

	%% Second reader's name? Ask the Colloquium Instructor who it will be.
	\reader{Name of Second Reader}

	\thesisyear{2018}
	\thesismonth{May}
%%% End of information section.


%%% New Environments

	% Environment for finite automata construction examples
	% Places explanatory text next to the relevant diagram
	\newenvironment{exstep}[1]
		{
			\begin{minipage}{0.5 \textwidth}
				#1
			\end{minipage} \begin{minipage}{0.5 \paperwidth}
		}
		{
			\end{minipage}\\[0.5 em]
		}


%%% End new environments 
	\newcommand{\footcite}[2]{\footnote{\cite[pg.~{#2}]{#1}}}
	\renewcommand{\footcite}[2]{\cite[pg.~{#2}]{#1}}
%%% New commands

%%% End new commands


%%% The start of the document!
\begin{document}

\ifbuildfrontmatter
\frontmatter

	\maketitle

	\begin{abstract}
		Your abstract goes here.
	\end{abstract}


	%%% If you want to thank someone for their influence on your life or your work, here's where you'd do it.
	\begin{acknowledgments}
		Here you should acknowledge any special help on your project, or particular influences on your life or mathematical development.
	\end{acknowledgments}

	%%% Table of Contents, List of Figures, and List of Tables. 
	% If you don't have any figures or tables in your report, you can
	% comment out the appropriate command.
	\tableofcontents
	% \listoffigures
	% \listoftables
%%% End of the front matter.
\fi

%%% Beginnning of the main matter.
\mainmatter

\mychapter{Basic Definitions}
\label{ch:basics}

		\begin{definition}[Symbol]
			The \textit{symbol} is the foundational unit of formal language theory.
			Symbols are distinct from each other; two symbols are interchangeable if and only they are the same symbol.
			Symbols are indivisible: a symbol may not be decomposed and represented by any other symbol or collection of other symbols.
		\end{definition}

		\begin{definition}[Alphabet]
			An \textit{alphabet} is a nonempty and finite set of symbols.
			An alphabet is typically denoted by the symbol $\Sigma$.
		\end{definition}

		\begin{definition}[String]
			A \textit{string} over an alphabet $\Sigma$ is a finite sequence of symbols of $\Sigma$.
			If $\Sigma = \{ a, b ,c \}$, then $w = acbba$ is a string over $\Sigma$.
			The length of a string is the number of symbols it contains (counting repetitions).
			The length of $w$, denoted $|w|$ is $5$.
			Strings are also referred to as \textit{words}.

			The string of length zero, which contains no symbols, is called the \textit{empty string}, and denoted $\lambda$.
			The empty string is a valid string over any alphabet.
		\end{definition}

		\begin{definition}[Language]
			A \textit{language} over an alphabet $\Sigma$ is any set of strings over $\Sigma$.
			% The language of all possible strings over $\Sigma$ is denoted $\Sigma^*$.

			The empty set ($\emptyset$) and $\{ \lambda \}$ are valid languages over any alphabet.

			Note that because languages are sets of strings, the conventional set operations, such as union, intersection, and complementation are defined for languages.
		\end{definition}

		\begin{remark}
			The empty set and $\{ \lambda \}$ represent distinct languages. 
			The empty set represents the language containing no strings at all, while $\{ \lambda \}$ represents the language containing only the empty string.
		\end{remark}


\mychapter{Regular Expressions} % (fold)
\label{ch:regular_expressions}
	
	\begin{definition}[Atomic Regular Languages]
		The \textit{atomic regular languages} are the basic units used to build all other regular languages.
		They are defined for any alphabet $\Sigma$ as follows:
		\begin{enumerate}[label=(\roman*), itemsep = -0.3 ex]
			\item $\emptyset$ is an atomic regular language over $\Sigma$.
			\item $\{ \lambda \}$ is an atomic regular language over $\Sigma$.
			\item $\{ a \}$ is an atomic regular language over $\Sigma$ for all $a \in \Sigma$.
		\end{enumerate}
	\end{definition}

	We now define some operations closely related to the family of regular languages.

	\begin{definition}[Concatenation]
		Let $w_1 = ac$ and $w_2 = bac$ be strings over some alphabet.
		Their \textit{concatenation} $w_1 w_2$ denotes the string $acbac$, and $w_2 w_1$ denotes $bacac$.
		For any string $w$, $\lambda w = w \lambda = w$.
		The notation $w^3$ denotes the string $www$, and $w^0 = \lambda$.

		It should be easy to see that this definition applies to symbols, which can be seen as words of length 1.

		\meo{I think I could choose better example strings here.}
	\end{definition}

	\begin{definition}[Concatenation of Languages]
		Let $A$ and $B$ be languages over some alphabet.
		Their \textit{concatenation}, or \textit{product}, $AB$ is the set $\{ ab \mid a \in A, \ b \in B \}$.
		The notation $A^2$ represents the language $AA$, and $A_i$ represents $AA^{i-1}$
		Note that $A = A^1 = AA^0 = \{ a \lambda \mid a \in A \}$, which implies that $A^0 = \{ \lambda \}$
	\end{definition}

	\begin{remark}
		Note that the set of strings over an alphabet is closed under concatenation: if $x$ and $y$ are strings over $\Sigma$, then so are $xy$ and $yx$.
		It follows that if $A$ and $B$ are languages over $\Sigma$, then so are $AB$ and $BA$.
		
		Concatenation is also an associative operation.
		Given strings $x$, $y$, and $z$, $(xy)z = x(yz)$.
		It follows that given languages $A$, $B$, and $C$, $(AB)C = A(BC)$.

		\meo{
			Maybe also note that length has the properties of the logarithm with regard to concatenation.
			It's a curiosity, but not really useful information
		}
	\end{remark}

	\begin{definition}[Kleene Closure]
		Given any language $A$, the language 
		\[
			A^* = \bigcup_{i \geq 0} A^i
		\]
		is called the \textit{Kleene closure} of $A$.\footcite{lemmings}{3}
		Note that this definition also provides the Kleene closure of symbols and words, and that the Kleene closure of a string or symbol is a language, not another string or symbol.
	\end{definition}

	\begin{definition}[Regular Operations]
		The following are referred to as the \textit{regular operations}:
		\begin{enumerate}[label=(\roman*), itemsep = -0.3 ex]
			\item Concatenation
			\item Union
			\item Kleene closure
		\end{enumerate}
	\end{definition}

	\begin{definition}[Regular Language]
		Given an alphabet $\Sigma$, any atomic regular language over $\Sigma$ is a regular language over $\Sigma$.
		If $A$ and $B$ are regular languages over $\Sigma$, then $AB$, $A \cup B$, and $A^*$ are regular languages over $\Sigma$.
	\end{definition}

	We now introduce \textit{regular expressions}, a shorthand for describing regular languages.

	\begin{definition}[Regular Expressions]
		The atomic regular expressions over any alphabet $\Sigma$ are defined to represent the atomic regular languages over $\Sigma$:
		\begin{enumerate}[label=(\roman*), itemsep = -0.3 ex]
			\item $\emptyset$ denotes the empty language.
			\item $\lambda$ denotes the language $\{ \lambda \}$.
			\item $a$ denotes the language $\{ a \}$ for all $a \in \Sigma$.
		\end{enumerate}

		If $\alpha$ and $\beta$ are regular expressions representing languages $A$ and $B$, respectively, then the following are also regular expressions:
		\begin{enumerate}[label=(\roman*), itemsep = -0.3 ex]
			\item $\alpha \beta$ denotes the language $AB$.
			\item $\alpha + \beta$ denotes the language $A \cup B$.
			\item $\alpha^*$ denotes the language $A^*$.
		\end{enumerate}
	\end{definition}

	\begin{remark}
		The distinction between regular expressions and regular languages is that regular expressions are a shorthand for describing regular languages. 
		Although regular expressions look very similar to the set notation for regular languages, they do simplify the notation, especially when describing complex languages.
		\meo{
			Is this a convincing reason why this is a thing worth having?
		}

	\end{remark}

	\meo{
		I could mention here that regular expressions are an example of a grammar, shockingly belonging to the class of regular grammars.
	}

% chapter regular_expressions (end)

\mychapter{Finite Automata} % (fold)
\label{ch:finite_automata}

	A finite automaton is a formal model of a machine which has a finite number of allowed configurations, called states, and accepts input symbols from some finite alphabet. 
	Each time a symbol is input to the automaton, it may transition to a new state. 
	The output of a finite automaton is the state of the machine after reading some input.

	\begin{definition}[Finite Automaton]
		A \textit{finite automaton} (FA) $M$ is defined by the 5-tuple $(Q, \Sigma, q_0, \delta, F)$.
		\begin{itemize}
			\item [] $Q$ is a finite and nonempty set of states.
			\item [] $\Sigma$ is an alphabet of possible input symbols.
			\item [] $q_0 \in Q$ is the state of the machine prior to any input, referred to as the \textit{initial state};
			\item [] $\delta: (Q \times \Sigma) \mapsto Q$ is called the \textit{transition function}: It maps a starting state and an input symbol to the new state of the machine.
			\item [] $F \subseteq Q$ is the set of \textit{final states} or \textit{accepting states} of the machine.
		\end{itemize}
	\end{definition}

	\begin{remark}
		It is convenient to extend the definition of $\delta$ to apply to strings, as well as individual symbols.
		Let $w = w_1 w_2 \dots w_n \in \Sigma^*$.
		By $\delta(q_1, w) = q_n$ we mean 
		\[
			\delta\bigg( \cdots \ \delta\Big( \ \delta(q_1, w_1), \ w_2 \Big), \cdots, w_n \bigg) = q_n.
		\]
		And define $\delta(q_i, \lambda) = q_i$.
		This defines $\delta: (Q \times \Sigma^*) \mapsto Q$.
	\end{remark}

	\begin{definition}(Acceptance by Finite Automaton)
		Let $M = (Q, \Sigma, q_0, \delta, F)$ be a FA and let $w \in \Sigma^*$.
		We say that $w$ is \textit{accepted} by $M$ if $\delta(q_0, w) \in F$.

		We use $L(M)$ to denote the language $\{ w \in \Sigma^* \mid \delta(q_0, w) \in F \}$ of all strings accepted by $M$.

		A language $A$ is called \textit{representable} if there exists some FA $M_A$ such that $A = L(M_A)$.
	\end{definition}

	\begin{example}[Finite Automata Construction]
		Give an illustrated step-by-step explanation of the construction of a finite automaton to recognize binary numbers divisible by three.

		We will construct a simple finite automaton to determine if a binary string represents a number divisible by three.
	Denote this $M_3 = (Q, q_0, \Sigma, \delta, F)$.
	Since the inputs are to be binary strings, we know $\Sigma = \{ 0, 1 \}$.
	We can also assume that each state of $M_3$ should represent the value of the current input modulo 3, so $Q = \{q_0, q_1, q_2\}$.
	Now we need an initial state. 
	We'll assume that the machine starts at $q_0$. 
	This makes sense, because we could achieve the same result by claiming to prefix every input string with a 0, as this would not change its value.
	Obviously, all numbers divisible by 3 will have a value of 0 modulo 3, so $F = \{q_0\}$.

	Now the only part of $M_3$ left undefined is $\delta$, the set of state transitions.

		\begin{exstep}
			{
				We begin with only the initial state.
				The input so far is $\lambda$.
			}
			\includestandalone{tikz/mod3_construction/step_1}
		\end{exstep}

		\begin{exstep}
			{
				With the 0 as the current state, suppose the first input symbol is 0. 
				Then the number so far is $0_b = 0 = 0 \mod 3$, so we add the following to $\delta$: $(q_0, 0, q_0)$.
			}
			\includestandalone{tikz/mod3_construction/step_2}
		\end{exstep}

		\begin{exstep}
			{
				Now suppose that the first input symbol is 1. 
				Then $1_b = 1 \mod 3$, so we need to add state $q_1$ to our drawing, and add $(q_0, 1, q_1)$ to $\delta$.
			}
			\includestandalone{tikz/mod3_construction/step_3}
		\end{exstep}

		\begin{exstep}
			{
				Now we have all the transitions we need from $q_0$, so we move on to $q_1$.
				We'll assume that the input so far is $1_b$.
				Then if the next input symbol is $0$, we have $10_b = 2 = 2 \mod 3$.
				So we add state $q_2$ to the diagram, and add $(q_1, 0, q_2)$ to $\delta$.
			}
			\includestandalone{tikz/mod3_construction/step_4}
		\end{exstep}

		\begin{exstep}
			{
				But if the next input is $1$, then we have $11_b = 3 = 0 \mod 3$.
				So we add $(q_1, 1, q_0)$ to $\delta$.
			}
			\includestandalone{tikz/mod3_construction/step_5}
		\end{exstep}
		

		\begin{exstep}
			{
			Now we have all possible transitions from $q_1$, so we move on to $q_2$.
			Assume that the input so far is $10_b$.
			if the next symbol is $0$, we will have $100_b = 1 \mod 3$, so we add $(q_2, 0, q_1)$ to $\delta$.
			}
			\includestandalone{tikz/mod3_construction/step_6}
		\end{exstep}
		
		\begin{exstep}
			{
				But if the next input is $1$, we will have $101_b = 5 = 2 \mod 3$.
				So we add $(q_2, 1, q_2)$ to $\delta$.
			}
			\includestandalone{tikz/mod3_construction/step_7}
		\end{exstep}
	\end{example}

	\begin{definition}[Deterministic and Nondeterministic Finite Automata]
		Explain the distinction between deterministic and nondeterministic finite automata.
		Mention the abbreviations ``DFA'' and ``NDFA.''
	\end{definition}
% chapter finite_automata (end)


\mychapter{Kleene's Theorem} % (fold)
\label{ch:kleenes_theorem}

	\begin{theorem}[Kleene's Theorem]
		A language is representable if and only if it is regular.
	\end{theorem}

	\begin{claim}
	\label{prop:regular_languages_representable}
		All regular languages are representable.
	\end{claim}

	\begin{proof}
		Proof of \refprop{prop:regular_languages_representable}
	\end{proof}

	\begin{claim}
	\label{prop:ndfa_dfa_equivalent}
		A language is representable by a NDFA if and only if it is representable by a DFA.
	\end{claim}

	\begin{proof}
	\label{proof:ndfa_dfa_equivalent}
		Proof of \refprop{prop:ndfa_dfa_equivalent}.
	\end{proof}

	\begin{claim}
	\label{prop:representable_languages_regular}
		All representable languages are regular.
	\end{claim}

	\begin{proof}
		Proof of \refprop{prop:representable_languages_regular}
	\end{proof}
	

	This completes the proof of Kleene's theorem.

% chapter kleenes_theorem (end)


\mychapter{Examples Illustrating Kleene's Theorem} % (fold)
\label{sec:examples}

	\begin{example}[Mod 3 Finite Automaton]
		Constructing regular expression from the mod 3 finite automaton.
		This will help explain the proof that all representable languages are regular.

		This example will also illustrate how the numbering of the states of an FA in the inductive step of the proof of \refprop{prop:representable_languages_regular} impacts the resulting regular expression (although all possible results are equivalent, they may look very different).
	\end{example}

	\meo{
		Figure out if there are any other parts of the proof that deserve an example to help explain them.
		I will probably include pictures for regular language $\iff$ representable in the initial proof.
	}

% chapter examples (end)

\mychapter{Motivation} % (fold)
\label{sec:motivation}
	\begin{remark}
		We have seen that any regular expression is convertible into a NDFA and that any NDFA is convertible into a DFA.
		Although we have not mentioned it, there is also an algorithm to minimize any DFA: producing an equivalent automaton with a minimal number of states. 
		With a minimal DFA accepting a regular language, we can use a transition matrix to search through data for strings of that language in $\bigo(N)$ time for the amount of data, and $\bigo(m^2)$ memory for the length of the regular expression.
	\end{remark}

	\begin{remark}
		Mention the use of regular language parsing in the design of compilers and interpreters, and mention the ubiquity of \texttt{grep}.
	\end{remark}
% chapter motivation (end)




\mychapter{Mathematical Notation}%
\label{ch:mathematical-notation}

You may find it useful to the reader to provide a table of notation. 

\mychapter{Conclusion(s)}
\label{ch:conclusion}


% chapter conclusion (end)


%\appendix
%%% Any appendices are delineated with the \appendix command.
%%% Individual appendices are begun with the standard \chapter or
%%% \section commands.  Use an appendix for any very long argument or side issue.

\backmatter

\nocite{*}
\bibliographystyle{plainnat}
\bibliography{references.bib}

\end{document}



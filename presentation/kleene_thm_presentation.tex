\documentclass[11 pt]{beamer}
\let\Tiny=\tiny

\usepackage{mathtools}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{bm}
\usepackage{graphicx}
\usepackage{pgfpages}
\usepackage[]{xcolor}
\usepackage{tikz}
\usepackage{subcaption}
\usepackage{float}

\newcommand{\meo}[1]{\texttt{#1}} % My Eyes Only: notes just for me
\newcommand{\bigo}{\mathcal{O}}
\newcommand{\extra}[1]{{\color{purple} {#1}}}
\newcommand{\click}{$\bm{\star}$}

\usetheme{default}
\usecolortheme{beaver}
\usefonttheme{serif}


\beamertemplatenavigationsymbolsempty
\setbeameroption{show notes}


\newif\ifpresstime
	\presstimefalse
	\presstimetrue

\mode<presentation>{
	\setbeameroption{hide notes}
}
\mode<handout>{
	\setbeameroption{show only notes}
	\pgfpagesuselayout{2 on 1}[letterpaper, border shrink=5mm]

}


\ifpresstime
		\renewcommand{\meo}[1]{}
		\date{April 13, 2018}
		\setbeameroption{hide notes}
	\else
		\setbeameroption{show notes}
		% \setbeameroption{show only notes}
		\date{\today}
	\fi

\usetikzlibrary{arrows, automata, shapes}
\tikzset{
		initial text = {\scriptsize{\textsc{start}}},
		initial distance = 1 pt,
		every initial by arrow/.style={->},
		elliptic state/.style={draw,rounded rectangle},
		accepting/.style ={thick, double}
	}


\title{Kleene's Theorem}
\author{James McFeeters}
\institute {Beloit College}
\begin{document}

\frame{
	\titlepage
}
\note[itemize]{
	\item Proof of Kleene's theorem
	\item Related to the popularity of regular expressions
	\item Start with an introduction to formal language theory, then prove Kleene's theorem, then go through examples and applications.
}

\begin{frame}
	\frametitle{Basic Definitions}
	\begin{itemize}
		\item Symbol
		\pause
		\item Alphabet ($\Sigma$)
		\pause
		\item String / word
		\begin{itemize}
			\pause
			\item The empty string ($\lambda$)
			\pause
			\item $|\lambda| = 0$
		\end{itemize}
		\pause
		\item Language
		\begin{itemize}
			\pause
			\item $\emptyset$
		\end{itemize}
	\end{itemize}
\end{frame}
\note{
	\textbf{Symbol:} The most basic unit of formal language theory --- like a letter in an alphabet.
	Can't be decomposed into anything and nothing can be combined into a symbol.

	\textbf{Alphabet:} A restricted set of symbols.
	0 and 1 for binary.
	We always assume that alphabets are nonempty and finite.

	\textbf{String:} or Word, a sequence of symbols.
	A string made entirely of symbols of one alphabet is called a string \textbf{over} that alphabet.
	We assume that strings are finite, but we don't assume that they are nonempty.
	\textbf{The Empty String:} Contains no symbols, is the string of length 0.
	Lambda is considered a string over any alphabet.
}
\note{
	\textbf{Language:} A set of strings. 
	The \textbf{empty} set is the language of NO strings over an alphabet.
	We could also just specify all the members of a language (like a dictionary).
	We're more interested in languages that are formed according to some rules so that we can describe the language without specifying all its members.
	We'll be dealing with the \textbf{regular languages}, which are formed using three set operations.
}


\begin{frame}
	\frametitle{Regular Operations}
	\begin{itemize}
		\item Union
		\item Concatenation
		\item Kleene Closure
	\end{itemize}
\end{frame}
\note{
	\textbf{Union:} probably familiar to everyone, all the strings from either language.

	Concatenation and Kleene Closure I need to define.

}


\begin{frame}
	\frametitle{Concatenation}
	\begin{columns}[T]
		\column{0.3\textwidth}
			\begin{block}{Strings}
				\begin{flalign*}
					w_1 &= ab &\\
					w_2 &= bc &\\
					w_1 w_2 &= abbc &\\
				\end{flalign*}
			\end{block}
		\column{0.5\textwidth}
		\pause
			\begin{block}{Languages}
				\begin{flalign*}
					AB &= \{ ab \mid a \in A, \, b \in B \} &\\
				\end{flalign*}
			\end{block}
	\end{columns}
	\begin{columns}[T]
		\column{0.3\textwidth}
		\pause
			\begin{flalign*}
				w^0 &= \lambda 		& \\
				w^1 &= w 			& \\
				w^2 &= ww			& \\
				w^k &= w w^{k-1} 	&
			\end{flalign*}
		\column{0.5\textwidth}
		\pause
			\begin{flalign*}
				A^0 &= \{ \lambda\} 					& \\
				A^1 &= A \{ \lambda \} = A 				& \\
				A^2 &= AA = \{ xy \mid x, y \in A \}	& \\
				A^k &= A A^{k-1}
			\end{flalign*}
	\end{columns}
\end{frame}
\note[itemize]{
	\item Concatenation of strings is simple --- just bolt one string onto the end of the other: ``run'' and ``way'' to get runway.

	\item For languages, we use the set product. 
		Any word of the first language concatenated with any word of the second language.

	\item A bit of notation that will make the Kleene Closure easier to understand.

	\item We use superscripts to denote concatenating a word with itself, or repeating the word some number of times.
		So repeating a word zero times gets us the empty string.

	\item The same is true for languages. 
		But note that repeating a language $n$ times doesn't get us all the strings in that language repeated $n$ times, it gets us any combination of $n$ words from that language.

}

\begin{frame}
	\frametitle{Kleene Closure}
	$A^*$: the \textbf{Kleene closure} of $A$.
	\pause
	\begin{align*}
		A^* &= \bigcup_{k \geq 0} A^k \\
		&= \{ \lambda \} \cup A \cup A^2 \cdots \\
	\end{align*}
	\pause
	If $A = \{ w \}$ then $A^* = \{ \lambda, \: w, \: ww, \: www, \: \dots\}$.\\[2 ex]
	\pause
	$\Sigma^*$: all strings over $\Sigma$.
\end{frame}
\note[itemize]{
	\item The Kleene closure of a language is that language repeated any number of times.
	\item If you have a language of just one word, you get the empty string, or that word repeated any number of times.
	\item So the Kleene closure of an alphabet is all the possible strings over the alphabet.


}

\begin{frame}
	\frametitle{Regular Languages}

	The \textbf{atomic} regular languages over an alphabet $\Sigma$ are
	\pause
	\begin{itemize}
		\item $\emptyset$
		\item $\{ \lambda \}$
		\item $\{ a \}$ for any $a \in \Sigma$ 
	\end{itemize}~\\[1 em]
	\pause

	If $A$ and $B$ are regular languages, then so are
	\begin{itemize}
		\item $A \cup B$
		\item $AB$
		\item $A^*$
	\end{itemize}
\end{frame}
\note[itemize]{
	\item The \textbf{atomic} regular languages are the regular languages over any arbitrary alphabet.
	\item They are the basis for all other regular languages.
	\item[\click] The language containing no strings.
	\item[\click] The language containing just the empty string.
	\item[\click] The language containing a one-symbol string for each symbol in the alphabet.
	\item[\click] And if $A$ and $B$ are regular languages, then so are their union, concatenation, and Kleene Closure.
}

\begin{frame}
	\frametitle{Regular Expressions}

	\pause
	Atomic regular expressions:
	\begin{itemize}
		\item $\emptyset$ means $\emptyset$
		\item $\lambda$ means $\{ \lambda \}$;
		\item $a$ means $\{ a \}$ for any $a \in \Sigma$.
	\end{itemize}~\\[1 ex]

	If $\alpha$ means $A$ and $\beta$ means $B$, then
	\begin{itemize}
		\item $\alpha \beta$ means $AB$;
		\item $\alpha + \beta$ means $A \cup B$;
		\item $\alpha^*$ means $A^*$.
	\end{itemize}
	
\end{frame}
\note[itemize]{
	\item Two ways of representing languages.

	\item[\click] The first is regular expressions
	\begin{itemize}
		\item Look pretty much the same as the set notation.
		\item We drop some braces
		\item We use a plus instead of the union symbol.
		\item Difference: two regular expressions are considered distinct, even if the languages they describe are exactly the same.
	\end{itemize}
}

\iffalse
\begin{frame}{Regular Expressions}
	\begin{exampleblock}{What's new here?}
	Languages:
	\[
		A^* \cup \{ \lambda \} = A^*
	\]
	\pause
	Expressions:
	\[
		\alpha^* + \lambda \neq \alpha^*
	\]
	\end{exampleblock}

\end{frame}
\note[itemize]{
	\item[] \textbf{What's new here?}
	\item Regular expressions aren't languages, they're descriptions of languages.
	\item Two regular expressions are considered distinct, even if the languages they describe are exactly the same.

	\item The next way of representing regular languages is will probably seem more different.
}
\fi

\begin{frame}
	\frametitle{Finite Automata}

	5-tuple: $M = (Q, \Sigma, s, \delta, F)$

	\begin{itemize}
		\pause
		\item [$Q$] the set of possible states. (Typically $q_1, q_2, \dots$.)
		\pause
		\item [$\Sigma$] the alphabet of input symbols.
		\pause
		\item [$s$] the initial state, $s \in Q$.
		\pause
		\item [$\delta$] the transition function:
		\pause
		\[
			\delta: (Q \times \Sigma) \to Q.
		\]
		\pause
		\item [$F$] the set of accepting states, $F \subseteq Q$.
	\end{itemize}
\end{frame}
\note{
	A \textbf{Finite automaton} is a machine with five parts.
	It has a finite number of configurations, which we call states.
	It moves between states when it receives an input symbol.
	Elevator example. (DON'T RAMBLE)
	We deal with machines that either \textbf{accept or reject} a string of inputs, based on the state of the machine after the input string.
	\begin{itemize}
		\item $Q$ is a set of states, really a set of names for states.
		These names are basically meaningless, typically they're just numbered.
		\item $\Sigma$ is the set of possible input symbols.
		\item $s$ is the state the machine starts in, before reading any input.
		\item $\delta$ tells the machine which state it should move to, given the current state and an input symbol, it outputs the next state.
		\item $F$ is all the states in which the machine is accepting the current input. Also sometimes called final states.
	\end{itemize}
}




\begin{frame}
	\frametitle{Building a Finite Automaton}
	\begin{center}
	\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm, initial below]
		\pause % 1
		\temporal<3>
		{\node[state] (q0)                     {$q_0$};}
		{\node[state, initial] (q0)            {$q_0$};}
		{\node[state, initial, accepting] (q0) {$q_0$};}
		\node[state]                   (q1) [right of = q0] {$q_1$};
		\node[state]                   (q2) [right of = q1] {$q_2$};
		\pause % 2 Plain q0
		\pause % 3 Initial q0
		\pause % 4 Accepting q0
		\pause % 5 Show Sigma
		\path[->] (q0) edge [loop above] node {0} (q0);
		\pause % 6
		\path[->] (q0) edge [bend left]  node {1} (q1);
		\pause % 7
		\path[->] (q1) edge [bend left]  node {0} (q2);
		\pause % 8
		\path[->] (q1) edge [bend left]  node {1} (q0);
		\pause % 9
		\path[->] (q2) edge [bend left]  node {0} (q1);
		\pause % 10
		\path[->] (q2) edge [loop right] node {1} (q2);
	\end{tikzpicture}
	\end{center}
	\visible<2->{$Q = \{ q_0, q_1, q_2 \}$}\\
	\visible<3->{$s = q_0$}\\
	\visible<4->{$F = \{ q_0 \}$}\\
	\visible<5->{$\Sigma = \{ 0, 1 \}$}
	~\\[2 ex]
	\visible<12->{Test: $10101_b = 21$}
\end{frame}
\note[itemize]{
	\item Build a finite automaton to accept binary numbers divisible by 3. (reading from the most significant bit).
	\item One state per possible value mod 3
	\item We start at 0, 
	\item We accept strings divisible by 3, so $q_0$ is our only accepting state
	\item The possible input symbols are obviously 0 and 1.
	\item Now go through the transitions.
	\item Test: $21 = 10101_b$
}

\begin{frame}
	\frametitle{More Fun with Automata}
	Extending the transition function:
	\pause
	\[
		\Delta : (Q \times \Sigma^*) \to Q
	\]
	\pause
	For $abc \in \Sigma^*$:
	\begin{align*}
		\Delta(q_1, abc) &= \delta \big( \Delta(q_1, ab), c \big) \\
		& = \delta \Big( \delta \big( \delta(q_1, a), b \big), c \Big) \\
	\end{align*}
	
	\pause
	No transitions on $\lambda$:
	\[
		\Delta(q_i, \lambda) = q_i
	\]

\end{frame}
\note[itemize]{
	\item We want to talk about the state of the machine after a string of inputs, not just after each symbol, so we want to extend the transition function
	\item So now we have a transition on any string, not just on a symbol.
	\item Define this by chaining together applications of the original transition function.
	\item We don't transition on the empty string (although it's equally valid to define automata that have lambda-transitions.)
}

\begin{frame}
	\frametitle{Finite Automata and Languages}
	The machine \textbf{accepts} $w$ if $\Delta(s, w) \in F$.\\[2 ex]
	\pause

	A machine \textbf{represents} $L(M) = \{ w \in \Sigma^* \mid \Delta(s, w) \in F \}$. \\[2 ex]
	\pause

	A language is \textbf{representable} if it can be represented by finite automaton.
\end{frame}
\note[itemize]{
	\item The machine accepts all the strings that take it from its start state to an accepting state
	\item The machine represents the language of all strings that take it from $s$ to an accepting state.
	\item Representable language --- can be represented by a finite automaton.
}

\begin{frame}
	\frametitle{Nondeterministic Automata}
	An automaton with multiple (or no) transitions from a state on a symbol?
	\pause

	\begin{center}
	\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm]
		\node[state, initial]   (q0)                 {$q_0$};
		\node[state]            (q1) [right of = q0] {$q_1$};
		\node[state, accepting] (q2) [right of = q1] {$q_2$};

		\path[->] (q0) edge [loop above] node {$a$} (q0);
		\path[->] (q0) edge              node {$a$} (q1);
		\path[->] (q1) edge              node {$b$} (q2);
	\end{tikzpicture}
	\end{center}
	\pause
	Accepts $ab, \, aab, \, aaab, \dots$.
\end{frame}
\note[itemize]{
	\item All the automata we've dealt with so far have exactly one transition from each state on each input, but this is not actually required.
	Automata with this restriction are DFAs.
	\item We can build automata without this restriction: they are called nondeterministic, abbreviated to NDFA.
	\item This automaton has two transitions from $q_0$ on $a$, to itself and to $q_1$. 
	\item Multiple transitions means more than one state ``active''.
	\item No transition $\implies$ dead state.
			There is no transition from $q_1$ on $a$, and no transition from $q_0$ on $b$.
	\item Talk about how it behaves.
}

\begin{frame}
	\frametitle{NDFAs are Tricky}
	We no longer have transitions to a single state.
	\[
		\delta : (Q \times \Sigma) \to 2^Q
	\]
	($2^Q$ is the set of all subsets of $Q$)\\[2 ex]

	\pause
	We write
	\[
		q_1 \in \delta(q_0, a) %\quad \text{ or } \quad q_1 \in \Delta(q_0, a)
	\]
	instead of 
	\[
		\delta(q_0, a) = q_1. %\quad \text{ or } \quad \Delta(q_0, a) = q_1
	\]
	~\\[2 ex]
	\pause
	An NDFA accepts $w$ if
	\[
		\Delta(s, w) \cap F \neq \emptyset.
	\]


\end{frame}
\note[itemize]{
	\item any subset of the states may be active at once, so we need define transitions to the power set of $Q$.
	\item Rather than say that a state IS EQUAL TO the result of a transition, we say that it is IN the result of the transition.
	\item An NDFA is accepts an input if any of its accepting states are active.
}

\begin{frame}
	\frametitle{Kleene's Theorem}
	A language representable if and only if it is regular.

	\begin{enumerate}
		\pause
		\item All regular languages are represented by an NDFA.
		\pause
		\item A language is representable by an NDFA if and only if it is representable by a DFA.
		\pause
		\item All representable languages are regular.
	\end{enumerate}
\end{frame}
\note[itemize]{
	\item A language is representable by a finite automaton if and only if it is regular.
	\item We prove this in three parts
	\item [\click] All regular languages are representable by an NDFA
	\item [\click] NDFAs and DFAs are equivalent, they represent the same family of languages.
	\item [\click] All representable languages are regular.
}


\begin{frame}
	\frametitle{The Atomic Regular Languages are Representable}
	\begin{figure}[H]
		\centering
		\visible<1->{
			\begin{subfigure}[b]{0.3 \textwidth}
				\centering
				\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm]
					\node[initial,state] (q0)                {$q_0$};
				\end{tikzpicture}
				\caption*{Accepts $\emptyset$}
			\end{subfigure}
		}
		\visible<2->{
			\begin{subfigure}[b]{0.3 \textwidth}
				\centering
				\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm]
					\node[initial,state, accepting] (q0)                {$q_0$};
				\end{tikzpicture}
				\caption*{Accepts $\{ \lambda \}$}
			\end{subfigure}
		}
		\visible<3->{
			\begin{subfigure}[b]{0.3 \textwidth}
				\centering
				\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm]
					\node[initial,state]    (q0)                 {$q_0$};
					\node[state, accepting] (q1) [right of = q0] {$q_1$};
					\path[->](q0) edge  node {$a$} (q1);
				\end{tikzpicture}
				\caption*{Accepts $\{ a \}$}
			\end{subfigure}
		}
	\end{figure}
\end{frame}
\note[itemize]{
	\item We first show that all the atomic regular languages are representable by constructing NDFAs to represent them.
	\item Then we construct automata for regular combinations
	\item It's easy to construct a machine that represent the empty set --- it just has to accept no strings at all.
	\item To accept just the empty string, we have an initial state that is accepting, and define no transitions. 
	(implicit is no transition means transition to dead state.)
	\item This should make the difference between the empty set and the empty string clear.
	\item Finally, single symbol.
}

\begin{frame}
	\frametitle{Combining Representable Languages}
	\begin{figure}[H]
		\centering
		\begin{subfigure}{0.5 \textwidth}
			\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm, initial left]
				\node[initial,state]    (q0)                   {$s_A$};
				\node[elliptic state]   (ma)  [right of  = q0] {$\quad M_A \quad$};
				\node[state, accepting] (fa)  [right of = ma]  {$F_A$};
				\path[->](q0) edge (ma);
				\path[->](ma) edge (fa);
			\end{tikzpicture}
			\caption*{$L(M_A) = A$}
		\end{subfigure}\\[2 em]
		\begin{subfigure}{0.5 \textwidth}
			\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm, initial left]
				\node[initial,state]    (q0)                   {$s_B$};
				\node[elliptic state]   (mb)  [right of  = q0] {$\quad M_B \quad$};
				\node[state, accepting] (fb)  [right of = ma]  {$F_B$};
				\path[->](q0) edge (mb);
				\path[->](mb) edge (fb);
			\end{tikzpicture}
			\caption*{$L(M_B) = B$}
		\end{subfigure}
	\end{figure}
\end{frame}
\note{
	If languages are representable we have machines that represent them.
	So we can combine these machines to represent combinations of the languages.\\[2 ex]

	Introduce my rough diagrams.
	Mention that the sets of states are not shown with perfect accuracy.

	\begin{itemize}
		\item $s$ is the start state
		\item $F$ is all the accepting states
		\item $M_A$ represents any state of the machine
		\item First arrow represents transitions from the initial state to any state of the automaton
		\item And the second arrow represents transitions from any state to any accepting state.
	\end{itemize}

}

\begin{frame}
	\frametitle{Union of Representable Languages}
	\begin{figure}[H]
		\centering
		\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2.4cm, initial left]
			\visible<2->{
				\node[initial,state]    (sab)                             {$s_\cup$};
			}

			\visible<1->{
				\node[state]            (sa)  [above right of = sab]      {$s_A$};
				\node[elliptic state]   (ma)  [right of = sa]             {$\quad M_A \quad$};
				\node[state,accepting]  (fa)  [right of = ma]             {$F_A$};
				\path[->](sa) edge (ma);
				\path[->](ma) edge (fa);

				\node[state]            (sb)  [below right of = sab]      {$s_B$};
				\node[elliptic state]   (mb)  [right of = sb]             {$\quad M_B \quad$};
				\node[state, accepting] (fb)  [right of = mb]             {$F_B$};
				\path[->](sb) edge (mb);
				\path[->](mb) edge (fb);
			}
			\visible<4->{
				\path[->](sab) edge [out=0, in=180, distance = 1.7 cm] (ma);
			}
			\visible<4->{
				\path[->](sab) edge [out=0, in=180, distance = 1.7 cm] (mb);
			}
			\visible<3->{
				\node  (sab_label)   [below of = sab,node distance=1cm, text width=3cm] {\footnotesize{Accepting when\\$\lambda \in A \cup B$}};
			}
		\end{tikzpicture}
	\end{figure}
\end{frame}
\note[itemize]{
	\item Need a machine to accept strings from either language.
	\item Connect $M_A$ and $M_B$ in parallel.
	\item keep all the states of $M_A$ and $M_B$
	\item Keep all the accepting states of $M_A$ and $M_B$.
	\item[\click] Add a new initial state which we'll link into both machines
	\item[\click] If either language contains the empty string, $s_\cup$ is accepting.
	\item[\click] Add transitions from $s_\cup$ to mimic those from $s_A$ and $s_B$.

}

\begin{frame}
	\frametitle{Concatenation of Representable languages}
	\begin{figure}[H]
		\centering
			\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=3cm, initial left]
				\visible<1->{
					\node[initial,state]    (sab)                   {$s_A$};
					\node[elliptic state]   (ma)  [right of = sab]  {$\quad M_A \quad$};
					\node[state]            (fa)  [right of = ma]   {$F_A$};
					\path[->](sab) edge (ma);
					\path[->](ma) edge (fa);

					\node[state]            (sb)  [below of = ma, node distance = 2cm]  {$s_B$};
					\node[elliptic state]   (mb)  [right of = sb]         {$\quad M_B \quad$};
					\node[state, accepting] (fb)  [right of = mb]         {$F_B$};
					\path[->](sb) edge (mb);
					\path[->](mb) edge (fb);
				}

				\visible<2->{
					\path[->](ma) edge  [out=0, in=180, below, distance=4cm]          (sb);
				}
				\visible<5->{
					\path[->](sab) edge [dashed,out=0, in=180, below, distance=2cm]   (mb);
				}
				\visible<4->{
					\node  (sab_label)   [below of = sab,node distance=1cm, text width=3cm] {\footnotesize{Accepting when\\$\lambda \in A \cap B$}};
				}
				\visible<3->{
					\node  (sb_label)    [below of = sb,node distance=1cm, text width=3cm]  {\footnotesize{Accepting when\\$\lambda \in  B$}};
				}
			\end{tikzpicture}
	\end{figure}
\end{frame}
\note[itemize]{
	\item Needs to accept strings of $A$ concatenated with strings of $B$.
	\item Connect the two machines in series
	\item Keep all the states of both machines
	\item The initial state of the new machine is the start state of $M_A$.
	\item The accepting states of $M_A$ are no longer accepting --- a string of $A$ needs to be followed by a string of $B$.
	\item The accepting states are the accepting states of $M_B$. 
	\item[\click] Add transitions to $s_B$ shadowing those into $F_A$
	\item[\click] If lambda is in $B$, then $s_B$ is an accepting state.
	\item[\click] $s_A$ is accepting if lambda is in both $A$ and $B$.
	\item[\click] If lambda in $A$, add transitions from $s_A$ that mimic those from $s_B$.
}

\begin{frame}
	\frametitle{Kleene Closure of a Representable Language}
	\begin{figure}[H]
		\centering
			\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2.5cm, initial left]
				\visible<2->{
					\node[initial,accepting,state]    (sas)                   {$s_{A^*}$};
				}

				\visible<1->{
					\node[state]            (sa)  [right of = sas]            {$s_A$};
					\node[elliptic state]   (ma)  [right of = sa]             {$\quad M_A \quad$};
					\node[state,accepting]  (fa)  [right of = ma]             {$F_A$};
					\path[->](sa) edge (ma);
					\path[->](ma) edge (fa);
				}

				\node (ghost_start)  [above of = sa,         node distance = 1 cm,   inner sep = 0 cm] {};
				\node (ghost_start2) [left of  =ghost_start, node distance = 0.1 cm, inner sep = 0 cm] {};

				\visible<3->{
					\path[-] (sas)          edge [out=0, in=180, above, distance = 1 cm] (ghost_start);
					\path[-] (ghost_start)  edge [out=0, in=180]                         (ghost_start2);
					\path[->](ghost_start)  edge [out=0, in=180, above, distance = 1 cm] (ma);
				}
				% I tried a Bezier, but I'd need more than 4 control points to get the results I want
				\node (ghost_end)  [below of = fa,        node distance = 1.2 cm, inner sep = 0 cm] {};
				\node (ghost_end2) [right of = ghost_end, node distance = 0.2 pt, inner sep = 0 cm] {};
				\node (ghost_mid)  [below of = ma,        node distance = 1.2 cm, inner sep = 0 cm] {};
				\node (ghost_mid2) [left of  = ghost_mid, node distance = 0.2 cm, inner sep = 0 cm] {};

				\visible<4->{
					\path[-]  (fa)         edge [out=0,   in=0,   below, distance = 1.5 cm] (ghost_end);
					\path[-]  (ghost_end2) edge [out=180, in=0]                             (ghost_end);
					\path[-]  (ghost_end)  edge [out=180, in=0]                             (ghost_mid);
					\path[-]  (ghost_mid2) edge [out=0,   in=0]                             (ghost_mid);
					\path[<-] (ma)         edge [out=180, in=180, below, distance = 1.5 cm] (ghost_mid);
				}
			\end{tikzpicture}
	\end{figure}
\end{frame}
\note[itemize]{
	\item add a new start state, accepting to accept $\lambda$.
	\item add transitions from $s_{A*}$ shadowing the transitions from $s_A$.
	\item Link $M_A$ to itself to form a circle.
	\item add transitions from every state in $F_A$ that mimic those from $s_A$.
	\item Now we have all the operations and all the atomics, so we can represent all the regular languages.
}

\begin{frame}
	\frametitle{NDFAs and DFAs are Equivalent}
	\textit{A language is representable by an NDFA if and only if it is representable by a DFA.}\\[1 em]
	\pause
	All DFAs are NDFAs: nothing to prove in that direction.\\[1 em]

	\pause
	For an NDFA $M = (Q, \Sigma, s, \delta, F)$ construct a DFA $M'$ such that
	\[
		L(M') = L(M).
	\]
\end{frame}
\note[itemize]{
	\item We need to show that any language represented by an NDFA can be represented by a DFA, and vice-versa.
	\item All DFAs are actually NDFAs already, so we don't have to worry about the vice-versa part.
	\item For any NDFA, we need to construct a DFA that accepts the same language.
	\item I'm just going to skim over the construction we use.
}

\begin{frame}
	\frametitle{Power Set Construction}
	\begin{itemize}
		\setlength\itemsep{2 ex}
		\pause
		\item[] $Q' = 2^Q$\\[1 ex]
		$\{ q_1, q_2, \dots, q_n \} \subseteq Q \quad \implies \quad \{ q_1, q_2, \dots, q_n \} \in Q'$.
		\pause
		\item[] $s' = \{ s \}$
		\pause
		\item[] $F' = \{ p \in Q' \mid p \cap F \neq \emptyset \}$
	\end{itemize}
	~\\[2 em]
	\pause
	We have 
	\begin{align*}
		M' = (Q', \Sigma, \{ s \}, \delta', F')
	\end{align*}
	
\end{frame}
\note[itemize]{
	\item Any subset of the states of $M$ may be active at any given time, so we need one state in $M'$ to represent each subset of $Q$.
	\item[\click] Thus the set of states for our DFA is the power set of the states of our NDFA.
	\item[\click] The initial state of $M'$ is the subset containing just the initial state of $M$.
	\item[\click] The accepting states of $M'$ are all the subsets that contain an accepting state of $M$.
	\item[\click] Everything except the transition function is defined

}

\begin{frame}
	\frametitle{Power Set Construction}
	For $a \in \Sigma$ define,
		\begin{align*}
			\delta'(\{ q_1, q_2, \dots, q_n \}, a) &= \delta(q_1, a) \cup \delta(q_2, a) \cup \cdots \cup \delta(q_n, a) \\
			&= \bigcup_{i = 1}^n \delta(q_i, a)
		\end{align*}

	\pause
	This works because
	\[
		\Delta'(\{ s \}, w) = \Delta(s, w) \quad \text{for all } w \in \Sigma^*
	\]
	which implies
	\[
		\Delta'(\{ s \}, w) \in F' \iff \Delta(s, w) \subseteq F.
	\]
\end{frame}
\note[itemize]{
	\item[\click] The transitions in $M'$ are defined as a union of transitions in $M$.
	\item[\click] This works because the active state in the DFA always corresponds exactly to the set of active states in the original NDFA
	\item Thus the set of inputs that lead to an accepting state correspond exactly. 
}

\begin{frame}
	\frametitle{All Representable Languages are Regular}

	\textit{We can construct a regular expression to describe the language accepted by any DFA.}\\[1 em]
	\pause

	Let $M$ be a DFA with states $Q = \{ q_1, q_2, \dots, q_n \}$
	\pause

	Let $1 \leq i, j \leq n$.\\
	Let $0 \leq k \leq n$.\\

	\pause



	Create a regular expression $R_k(i, j)$. 
	Takes $M$ from $q_i$ to $q_j$ without passing through a state numbered higher than $k$.

	\[
		R_0(i, j) = \{ a \in \Sigma \cup \{ \lambda \} \mid \delta(q_i, a) = q_j \}
	\]


	\[
		R_{k+1}(i, j) = R_k(i, j) + (R_k(i, k) \; (R_k(k+1, k+1))^* \; R_k(k, j))
	\]


\end{frame}
\note[itemize]{
	\item We have just shown that DFAs and NDFAs are equivalent, so we need only show that any language represented by a DFA is regular.
	\item We have a DFA with states numbered from $1$ to $n$.
	\item Examine the language that can take $M$ from $q_i$ to $q_j$ without passing through any states numbered higher than $k$.
	\item So for $k = 0$, we only consider direct transitions.
	\item For $k = 1$, we are only allowed to pass through $q_1$, and so on.
	\item 
	\item This completes the proof of Kleene's theorem.
}

\begin{frame}
	\frametitle{Example}
	Remember this?
	\begin{figure}[H]
		\centering
		\begin{tikzpicture}[>=stealth',shorten >= 1 pt, auto, node distance = 2 cm]
			\node[initial,state,accepting] (q0)                 {$q_3$};
			\node[state]                   (q1) [right of = q0] {$q_1$};
			\node[state]                   (q2) [right of = q1] {$q_2$};

			\path[->](q0) edge [loop above] node {0} (q0);
			\path[->](q0) edge [bend left]  node {1} (q1);
			\path[->](q1) edge [bend left]  node {0} (q2);
			\path[->](q1) edge [bend left]  node {1} (q0);
			\path[->](q2) edge [bend left]  node {0} (q1);
			\path[->](q2) edge [loop right] node {1} (q2);
		\end{tikzpicture}
	\end{figure}
	It's numbered differently than before!
\end{frame}
\note[itemize]{
	\item We have to number the states starting at 1, not 0.
	\item This is the intuitive way to change the numbering
}
\begin{frame}[shrink]
	\frametitle{References}
	\bibliographystyle{amsplain}
	\nocite{*}
	\bibliography{../paper/references.bib}
\end{frame}

\end{document}
